#!/bin/bash
# Given a list of packages, generate their buildoort
#  buildroot means what it would take to build not only that 
#  package, but all the packages to build the packages.
#

#####
# Variables
#####
WORK_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
source $WORK_DIR/conf/config.inc

TIMESTAMP=$(date +%Y-%m-%d-%H:%M)

# BINARY VARIABLES
: ${VERBOSE:="FALSE"}
: ${LAYERS:="TRUE"}
# LIST VARIABLES
#ORIGINAL_LIST=()
BINARY_LIST=()
# ASSOCIATIVE ARRAY VARIABLES
declare -A SOURCE_LIST

# Given a list of binary packages, get the source name, and add it to the source_list
get_source_name(){
  if [ "${VERBOSE}" == "TRUE" ] ; then
    echo "   Gathering source names from binary names"
  fi
  this_source_name=($(dnf ${DNF_OPTIONS} repoquery --qf '%{source_name}' $@ 2>/dev/null | grep -v -i -e '^None$' -e '^(none)$' -e 'Subscription Management'))
  for this_source in ${this_source_name[@]}
   do
    if [ ! -v SOURCE_LIST[${this_source}] ]; then
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "    ADDING SOURCE: ${this_source}"
      fi
      SOURCE_LIST[${this_source}]=1
    fi
   done
}

#####
# Work through everything one arch at a time
#####
for this_arch in ${ARCH_LIST[@]}
do

  #####
  # Setup
  #####
  dnf --quiet --forcearch=${this_arch} clean all
  ORIGINAL_LIST=()
  BINARY_LIST=()
  SOURCE_LIST=()
  LAYER=1
  PACKAGE_LIST_FILE="${PACKAGE_LIST_HEAD}.${this_arch}"
  PACKAGE_NVR_LIST_FILE="${PACKAGE_NVR_LIST_HEAD}.${this_arch}"
  SOURCE_LIST_FILE="${SOURCE_LIST_HEAD}.${this_arch}"
  SOURCE_NVR_LIST_FILE="${SOURCE_NVR_LIST_HEAD}.${this_arch}"
  DATA_DIR="${DATA_DIR_BASE}/${this_arch}"
  export DNF_OPTIONS=" --forcearch=${this_arch} ${DNF_OPTIONS_BASE}"
  if [ -d ${DATA_DIR}/${NEW_DIR} ] ; then
    rm -f ${DATA_DIR}/${NEW_DIR}/*
  else
    mkdir -p ${DATA_DIR}/${NEW_DIR}
  fi
  echo "${TIMESTAMP}" > ${DATA_DIR}/${NEW_DIR}/${BR_TIMESTAMP_FILENAME}
  # cp ${PACKAGELIST_DIR}/${PACKAGE_LIST_FILE} ${DATA_DIR}/${NEW_DIR}/${PACKAGE_LIST_FILE}
  # cp ${PACKAGELIST_DIR}/${SOURCE_LIST_FILE} ${DATA_DIR}/${NEW_DIR}/${SOURCE_LIST_FILE}
  # We have to build them all for each arch, let's put them all in from the start
  cp ${PACKAGELIST_DIR}/${PACKAGE_LIST_HEAD}.all-arches ${DATA_DIR}/${NEW_DIR}/${PACKAGE_LIST_FILE}
  cp ${PACKAGELIST_DIR}/${PACKAGE_NVR_LIST_HEAD}.all-arches ${DATA_DIR}/${NEW_DIR}/${PACKAGE_NVR_LIST_FILE}
  cp ${PACKAGELIST_DIR}/${SOURCE_LIST_HEAD}.all-arches ${DATA_DIR}/${NEW_DIR}/${SOURCE_LIST_FILE}
  cp ${PACKAGELIST_DIR}/${SOURCE_NVR_LIST_HEAD}.all-arches ${DATA_DIR}/${NEW_DIR}/${SOURCE_NVR_LIST_FILE}
  
  #####
  # Work
  #####
  echo "  Creating BuildRoot for ${this_arch} ..."
  
  ## Find the sources for the original packages
  # Load Original List
  #ORIGINAL_LIST="$(cat ${PACKAGELIST_DIR}/${PACKAGE_LIST_FILE})"
  #if [ ${#ORIGINAL_LIST[@]} -le 0 ] ; then
  #    echo "NO PACKAGES LISTED"
  #    echo
  #    exit 5
  #else
  #  get_source_name "${ORIGINAL_LIST[@]} $(dnf ${DNF_OPTIONS} repoquery --qf %{name} --requires --resolve --recursive ${ORIGINAL_LIST[@]} 2>/dev/null)"
  #fi
  
  # Load Original Source List
  for this_source in $(cat ${PACKAGELIST_DIR}/${SOURCE_LIST_HEAD}.all-arches)
   do
    if [[ ! " ${SOURCE_LIST[@]} " =~ " ${this_source} " ]]; then
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "    ADDING SOURCE: ${this_source}"
      fi
      SOURCE_LIST[${this_source}]=1
    fi
   done

  # Loop through until we no longer add sources
  number_sources=${#SOURCE_LIST[@]}
  number_new_sources=${number_sources}
  while [ ${number_new_sources} -ge 1 ]
  do
    if [ "${VERBOSE}" == "TRUE" ] || [ "${LAYERS}" == "TRUE" ] ; then
      echo "Layer: ${LAYER} Number Sources: ${number_sources} New Sources: ${number_new_sources}"
    fi
    let LAYER=${LAYER}+1
    BINARY_LIST=($(dnf ${DNF_OPTIONS} repoquery --srpm --qf %{name} --requires --resolve ${!SOURCE_LIST[@]} 2>/dev/null))
    if [ ${#BINARY_LIST[@]} -le 0 ] ; then
      BINARY_LIST=($(dnf ${DNF_OPTIONS} repoquery --srpm --qf %{name} --requires --resolve ${!SOURCE_LIST[@]} 2>/dev/null))
      if [ ${#BINARY_LIST[@]} -le 0 ] ; then
        echo "ERROR IN DNF - BINARY PACKAGE LIST IS NOW EMPTY"
        echo
        exit 5
      fi
    fi
    get_source_name "${BINARY_LIST[@]}"
    get_source_name "$(dnf ${DNF_OPTIONS} repoquery --qf %{name} --requires --resolve --recursive ${BINARY_LIST[@]} 2>/dev/null )"
  
    new_number_sources=${#SOURCE_LIST[@]}
    let number_new_sources=${new_number_sources}-${number_sources}
    number_sources=${new_number_sources}
  done

  # Write it all out
  echo "Writting everything to disk"
  printf "%s\n" "${!SOURCE_LIST[@]}" | sort -u -o ${DATA_DIR}/${NEW_DIR}/${BR_SOURCE_PKGNAMES_FILENAME}
  printf "%s\n" "${BINARY_LIST[@]}" | sort -u -o ${DATA_DIR}/${NEW_DIR}/${BR_BINARY_PKGNAMES_FILENAME}
  dnf ${DNF_OPTIONS} repoquery --srpm --qf "%{name}-%{version}-%{release}.%{arch}" ${!SOURCE_LIST[@]} 2>/dev/null | sort -u -o ${DATA_DIR}/${NEW_DIR}/${BR_SOURCE_NVRS_FILENAME}
  dnf ${DNF_OPTIONS} repoquery --qf "%{name}-%{version}-%{release}.%{arch}" ${BINARY_LIST[@]} | grep -v .src$ 2>/dev/null | sort -u -o ${DATA_DIR}/${NEW_DIR}/${BR_BINARY_NVRS_FILENAME}
# finish with this arch
done
exit 0
