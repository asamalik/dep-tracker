#!/bin/bash
# Track dependendencies of a list of packages
#  and do something (usuall email) when the dependencies change
#

#####
# Variables
#####
TIMESTAMP=$(date +%Y-%m-%d-%H:%M)
WORK_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
#WORK_DIR="~/.dep-tracker"
CONF_DIR="${WORK_DIR}/conf"
DATA_DIR="${WORK_DIR}/data"
REPO_DIR="${WORK_DIR}/repos"
PACKAGE_DIR="${WORK_DIR}/packages"
PACKAGE_CONVERT="${PACKAGE_DIR}/convert/convert.package.nvr.name"
PACKAGE_ARCHIVE_DIR=${PACKAGE_DIR}/archive/${TIMESTAMP}
#LOG_DIR="${WORK_DIR}/logs"
#LOG_FILE="${LOG_DIR}/dt.logs"
MAIN_CONF="dt.conf"
PACKAGE_LIST="buildroot-initial-binary-package-list.txt"
NEW_DIR="new"
LAST_DIR="last"
DNF_OPTIONS=" -c ${REPO_DIR}/rawhide.repo --disablerepo=* --enablerepo=dt-rawhide --enablerepo=dt-rawhide-source "
DNF_SOURCE_ONLY_OPTIONS=" -c ${REPO_DIR}/rawhide.repo --disablerepo=* --enablerepo=dt-rawhide-source "
# BINARY VARIABLES
VERBOSE="FALSE"
LAYERS="TRUE"
# LIST VARIABLES
ORIGINAL_LIST=()
SOURCE_LIST=()
BINARY_LIST=()
LAYER=1

# Given a list of source name, archive then update the package info
archive_and_update(){
  this_source="${1}"
  if [ "${this_source}" == "" ] ; then
    echo "archive_and_update needs a source, nothing was provided"
    return 1
  fi
  mkdir -p ${PACKAGE_ARCHIVE_DIR}
  if [ -f  ${PACKAGE_DIR}/${this_source} ] && [ -f  ${PACKAGE_ARCHIVE_DIR}/${this_source} ] ; then
    # the source has already been archived, nothing to do
    return 0
  else
    if [ -f  ${PACKAGE_DIR}/${this_source} ] ; then
      mv ${PACKAGE_DIR}/${this_source} ${PACKAGE_ARCHIVE_DIR}/${this_source}
    fi
    dnf ${DNF_OPTIONS} repoquery --qf="%{name}" list  $(dnf ${DNF_OPTIONS}  repoquery --srpm --qf="%{sourcerpm}" --requires --resolve ${this_source} 2>/dev/null | grep -v Subscription | sed "s/.rpm$//") 2>/dev/null | grep -v Subscription | sort -u -o ${PACKAGE_DIR}/${this_source}
  fi
  return 0
}

# Given a list of binary packages, get the source name, and add it to the source_list
get_source_name(){
  if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "   GATHERING SOURCE NAMES FROM LIST OF BINARIES"
  fi
  #echo "  this_source_name= (dnf ${DNF_OPTIONS} repoquery --qf %{name} (dnf ${DNF_OPTIONS} repoquery --qf %{sourcerpm} $@ 2>/dev/null| sed 's/.rpm$//') 2>/dev/null)"
  this_source_name="$(dnf ${DNF_OPTIONS} repoquery --qf %{name} $(dnf ${DNF_OPTIONS} repoquery --qf %{sourcerpm} $@ 2>/dev/null| grep -v -e ^None$ -e "Subscription Management" | sed 's/.rpm$//') 2>/dev/null | grep -v -e ^None$ -e "Subscription Management")"
  for this_source in ${this_source_name[@]}
   do
    #echo "    SOURCE: ${this_source}"
    if [[ ! " ${SOURCE_LIST[@]} " =~ " ${this_source} " ]]; then
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "    ADDING SOURCE: ${this_source}"
      fi
      SOURCE_LIST+=("${this_source}")
      #if [ "${LAYERS}" == "TRUE" ] ; then
      #  echo ${this_source} >> ${OUTPUT_FILE}.layer${LAYER}
      #fi
    fi
   done
}

convert_source_to_name(){
  #if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "   CONVERTING SOURCE NVRs TO NAMES"
  #fi
  file_in="${1}"
  file_out="${2}"
  if [ "${file_in}" == "" ] || [ "${file_out}" == "" ] ; then
    echo "ERROR: convert_source_to_name needs two filenames - received: ${file_in} and ${file_out}"
    exit 21
  fi
  rm -f ${file_out}
  if ! touch ${file_out} ; then
    echo "ERROR: cannot use output file: ${file_out}"
    exit 22
  fi
  if [ -s ${file_in} ] ; then
    cat ${file_in} | while read this_line
    do
       binary_name=$(echo "${this_line}" | awk '{print $1}')
       source_nvr=$(echo "${this_line}" | awk '{print $2}')
       source_name=$(grep "^${source_nvr} " ${PACKAGE_CONVERT} | awk '{print $2}')
       if [ "${source_name}" == "" ] ; then
         new_source_nvr=$(echo ${source_nvr} | sed 's/.rpm$//')
         source_name=$(dnf ${DNF_OPTIONS} repoquery --qf %{name} ${new_source_nvr} 2>/dev/null | grep -v -e ^None$ -e "Subscription Management")
         if [ "${source_name}" == "" ] ; then
           echo "     ERROR: No Source name found for: ${source_nvr}"
         else
           #if [ "${VERBOSE}" == "TRUE" ] ; then
             echo "     New Package: ${source_nvr} ${source_name}"
           #fi
           echo "${source_nvr} ${source_name}" >> ${PACKAGE_CONVERT}
         fi
       fi
       echo "${binary_name} ${source_name}" >> ${file_out}
     done
  else
    echo "ERROR: No file with content: ${file_in}"
    exit 24
  fi
}

#####
# Setup
#####
#dnf --quiet clean all
ORIGINAL_LIST=()
SOURCE_LIST=()
BINARY_LIST=()
LAYER=1
things_changed="False"
if ! [ -d ${DATA_DIR}/archive ] ; then
  mkdir -p ${DATA_DIR}/{archive,logs,${NEW_DIR},${LAST_DIR}}
  mkdir -p ${PACKAGE_DIR}/convert
  last_change_date="NEVER"
else
  last_change_date="$(cat ${DATA_DIR}/${LAST_DIR}/buildroot-date-check.txt)"
fi
rm -f ${DATA_DIR}/${NEW_DIR}/*
echo "${TIMESTAMP}" > ${DATA_DIR}/${NEW_DIR}/buildroot-date-check.txt
cp ${CONF_DIR}/${PACKAGE_LIST} ${DATA_DIR}/${NEW_DIR}/
# Conf Parsing
ORIGINAL_LIST="$(cat ${CONF_DIR}/${PACKAGE_LIST})"
email_list="$(grep ^Email: ${CONF_DIR}/${MAIN_CONF} | cut -d' ' -f2-)"
action_list="$(grep ^Action: ${CONF_DIR}/${MAIN_CONF} | cut -d' ' -f2-)"

#####
# Work
#####
# Do the checks
echo "  Checking ..."
echo "# Buildroot Source Changes" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
echo "Checked on ${TIMESTAMP}" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
echo "" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
echo "Last time there was a change was [${last_change_date}](https://github.com/minimization/square1-results/blob/master/docs/archives/${last_change_date}/data/buildroot-changes.md)" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md

# Default: Always check if the package list has changed
if diff --brief ${DATA_DIR}/${NEW_DIR}/${PACKAGE_LIST} ${DATA_DIR}/${LAST_DIR}/${PACKAGE_LIST} > /dev/null 2>&1 ; then
	  echo "    No change in package list"
else
	  things_changed="True"
	  echo "    There were changes in the package list"
    if [ "${last_change_date}" == "NEVER" ] ; then
      packages_added="$(cat ${CONF_DIR}/${PACKAGE_LIST})"
      packages_removed=""
    else
	    packages_added="$(comm -23 ${DATA_DIR}/${NEW_DIR}/${PACKAGE_LIST} ${DATA_DIR}/${LAST_DIR}/${PACKAGE_LIST} 2>/dev/null)"
	    packages_removed="$(comm -13 ${DATA_DIR}/${NEW_DIR}/${PACKAGE_LIST} ${DATA_DIR}/${LAST_DIR}/${PACKAGE_LIST} 2>/dev/null)"
	  fi
	  #echo "ADDED: ${packages_added}"
	  #echo "REMOVED: ${packages_removed}"
    if ! [ "${packages_added}" == "" ] ; then
	    echo "## BINARY PACKAGES ADDED" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
	    echo "* ${packages_added}" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
    fi
    if ! [ "${packages_removed}" == "" ] ; then
	    echo "## BINARY PACKAGES REMOVED" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
	    echo "* ${packages_removed}" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
  	fi
	  echo  >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
fi

## Find the sources for the original packages
if [ ${#ORIGINAL_LIST[@]} -le 0 ] ; then
    echo "NO PACKAGES LISTED"
    echo
    usage
    exit 5
else
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "Original Binaries: ${ORIGINAL_LIST[@]}"
      get_source_name "${ORIGINAL_LIST[@]}"
      echo "Initial Source List: ${SOURCE_LIST[@]}"
    else
      get_source_name "${ORIGINAL_LIST[@]}"
    fi
fi

# Loop through until we no longer add sources
number_sources=${#SOURCE_LIST[@]}
number_new_sources=${number_sources}
while [ ${number_new_sources} -ge 1 ]
do
    if [ "${VERBOSE}" == "TRUE" ] || [ "${LAYERS}" == "TRUE" ] ; then
      echo "Layer: ${LAYER} Number Sources: ${number_sources} New Sources: ${number_new_sources}"
    fi
    let LAYER=${LAYER}+1
  
    get_source_name "$(dnf ${DNF_OPTIONS} repoquery --srpm --qf %{name} --requires --resolve ${SOURCE_LIST[@]} 2>/dev/null)"
  
    new_number_sources=${#SOURCE_LIST[@]}
    let number_new_sources=${new_number_sources}-${number_sources}
    number_sources=${new_number_sources}
done
  
# Write it all out
printf "%s\n" "${SOURCE_LIST[@]}" | sort -o ${DATA_DIR}/${NEW_DIR}/buildroot-source-package-names.txt
  
# Check if there were changes
echo "  Checking source deps against last set"
if diff --brief ${DATA_DIR}/${NEW_DIR}/buildroot-source-package-names.txt ${DATA_DIR}/${LAST_DIR}/buildroot-source-package-names.txt > /dev/null 2>&1 ; then
    echo "      No change in source deps"
    cp ${DATA_DIR}/${LAST_DIR}/binary-source-name.txt ${DATA_DIR}/${NEW_DIR}/binary-source-name.txt
    echo "## SOURCE DEPENDENCIES ADDED" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
    echo "Total New Sources Added: 0" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md      
    echo "## SOURCE DEPENDENCIES REMOVED" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
    echo "Total Sources Removed: 0" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
else
    things_changed="True"
    echo "      There were changes in source deps"
    if [ "${last_change_date}" == "NEVER" ] ; then
      source_deps_added="$(cat ${DATA_DIR}/${NEW_DIR}/buildroot-source-package-names.txt)"
      source_deps_removed=""
    else
      source_deps_added="$(comm -23 ${DATA_DIR}/${NEW_DIR}/buildroot-source-package-names.txt ${DATA_DIR}/${LAST_DIR}/buildroot-source-package-names.txt 2>/dev/null)"
      source_deps_removed="$(comm -13 ${DATA_DIR}/${NEW_DIR}/buildroot-source-package-names.txt ${DATA_DIR}/${LAST_DIR}/buildroot-source-package-names.txt 2>/dev/null)"
    fi
    #echo "ADDED: ${source_deps_added}"
    #echo "REMOVED: ${source_deps_removed}"
    # Update all added and removed source deps
    for changed_source in $(echo ${source_deps_added} ${source_deps_removed})
      do
        archive_and_update ${changed_source}
      done

    # Work on added source deps
    echo "## SOURCE DEPENDENCIES ADDED" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
    if ! [ "${source_deps_added}" == "" ] ; then
      echo "        Added packages"
      # Update binary-source-name.txt
      dnf ${DNF_OPTIONS} repoquery --srpm --qf "%{name} %{sourcerpm}" --requires --resolve ${SOURCE_LIST[@]} 2>/dev/null | grep -v -e ^None$ -e "Subscription Management" | sort -o ${DATA_DIR}/${NEW_DIR}/binary-source-name.txt.tmp
      convert_source_to_name ${DATA_DIR}/${NEW_DIR}/binary-source-name.txt.tmp ${DATA_DIR}/${NEW_DIR}/binary-source-name.txt
      rm -f ${DATA_DIR}/${NEW_DIR}/binary-source-name.txt.tmp
      # Work with added sources
      echo "${source_deps_added}" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes-sources-added.txt
      echo "Total New Sources Added: $(cat ${DATA_DIR}/${NEW_DIR}/buildroot-changes-sources-added.txt | wc -l )" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
      echo "" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
      echo "PA = Package Added  R = Requires Added Package  OLD = Not New" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
      for added_source in $(echo ${source_deps_added})
      do
        echo "* ${added_source} PA" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
        for added_binary in $(grep " ${added_source}$" ${DATA_DIR}/${NEW_DIR}/binary-source-name.txt | awk '{print $1}')
          do
            for wants_added in $(dnf ${DNF_OPTIONS} repoquery --qf "%{name}" --whatrequires ${added_binary} 2>/dev/null | grep -v -e ^None$ -e "Subscription Management")
              do
                # Only work with packages we already know about.  Otherwise you end up with everything.
                if [ -f  ${PACKAGE_DIR}/${wants_added} ] || [ -f  ${PACKAGE_ARCHIVE_DIR}/${wants_added} ] ; then
                  if ! [ "${added_binary}" == "${wants_added}" ] ; then
                    added_extra="R"
                    if grep -q ^${wants_added}$ ${DATA_DIR}/${LAST_DIR}/buildroot-source-package-names.txt ; then
                      added_extra="R OLD"
                      echo ${wants_added} >> ${DATA_DIR}/${NEW_DIR}/packages.with.changed.dependencies.txt
                    fi
                    echo "  * ${wants_added}  ${added_extra}" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
                    archive_and_update ${wants_added}
                  fi
                fi
              done
          done
      done
    else
      echo "Total New Sources Added: 0" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md      
    fi
    # Work on removed source deps
    echo "## SOURCE DEPENDENCIES REMOVED" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
    if ! [ "${source_deps_removed}" == "" ] ; then
      echo "        Removed packages"
      # Work with removed sources
      echo "${source_deps_removed}" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes-sources-removed.txt
      echo "Total Sources Removed: $(cat ${DATA_DIR}/${NEW_DIR}/buildroot-changes-sources-removed.txt | wc -l )" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
      echo "" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
      echo "PR = Package Removed  N = No longer Needs removed package, or was also removed" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
      for removed_source in $(echo ${source_deps_removed})
      do
        echo "* ${removed_source} PR" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
        for wants_removed in $(grep -l ^${removed_source}$ ${PACKAGE_ARCHIVE_DIR}/* ${PACKAGE_DIR}/* 2>/dev/null | awk -F "/" '{print $NF}' | sort -u)
        do
          if ! [ "${removed_source}" == "${wants_removed}" ] ; then
            echo "  * ${wants_removed}  N" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
            archive_and_update ${wants_removed}
          fi
        done
        rm -f ${PACKAGE_DIR}/${removed_source}
      done
    else
      echo "Total Sources Removed: 0" >> ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
    fi
fi

# If there were changes, do that thing you do
if [ "${things_changed}" == "True" ] ; then
	  echo "  There were changes."
		echo "    Archiving results"
		mkdir -p ${DATA_DIR}/archive/${TIMESTAMP}
		cp ${DATA_DIR}/${NEW_DIR}* ${DATA_DIR}/archive/${TIMESTAMP}/ 2>/dev/null
		echo "    Setting new files to be the last ones"
		rm -f ${DATA_DIR}/${LAST_DIR}/*
		cp ${DATA_DIR}/${NEW_DIR}/* ${DATA_DIR}/${LAST_DIR}/
		for action in ${action_list}
		do
      case ${action} in
        email | EMAIL | Email )
          echo "    Mailling out results"
          #mail -s "Dep Tracker: ${customer} results found" ${email_list} < ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
        ;;
        package | packages | Package )
          echo "    Mailling out results"
          #mail -s "Dep Tracker: ${customer} results found" ${email_list} < ${DATA_DIR}/${NEW_DIR}/buildroot-changes.md
        ;;
        *)
          echo "    ${action} is not implemented"
        ;;
      esac
		done
fi
