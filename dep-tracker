#!/bin/bash
# Track dependendencies of a list of packages
#  and do something (usuall email) when the dependencies change
#

#####
# Variables
#####
TIMESTAMP=$(date +%Y-%m-%d-%H:%M)
WORK_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
#WORK_DIR="~/.dep-tracker"
#CONF_DIR="${WORK_DIR}/conf"
CUST_DIR="${WORK_DIR}/customers"
REPO_DIR="${WORK_DIR}/repos"
PACKAGE_DIR="${WORK_DIR}/packages"
PACKAGE_CONVERT="${PACKAGE_DIR}/convert/convert.package.nvr.name"
PACKAGE_ARCHIVE_DIR=${PACKAGE_DIR}/archive/${TIMESTAMP}
#LOG_DIR="${WORK_DIR}/logs"
#LOG_FILE="${LOG_DIR}/dt.logs"
CUST_CONF="dt.conf"
CUST_LIST="package.list"
CUST_NEW_DIR="new"
CUST_LAST_DIR="last"
DNF_OPTIONS=" -c ${REPO_DIR}/rawhide.repo --disablerepo=* --enablerepo=dt-rawhide --enablerepo=dt-rawhide-source "
DNF_SOURCE_ONLY_OPTIONS=" -c ${REPO_DIR}/rawhide.repo --disablerepo=* --enablerepo=dt-rawhide-source "
# BINARY VARIABLES
VERBOSE="FALSE"
LAYERS="TRUE"
# LIST VARIABLES
ORIGINAL_LIST=()
SOURCE_LIST=()
BINARY_LIST=()
LAYER=1

#####
# Setup
#####
#dnf --quiet clean all
mkdir -p 

# Given a list of source name, archive then update the package info
archive_and_update(){
  this_source="${1}"
  if [ "${this_source}" == "" ] ; then
    echo "archive_and_update needs a source, nothing was provided"
    return 1
  fi
  mkdir -p ${PACKAGE_ARCHIVE_DIR}
  if [ -f  ${PACKAGE_DIR}/${this_source} ] && [ -f  ${PACKAGE_ARCHIVE_DIR}/${this_source} ] ; then
    # the source has already been archived, nothing to do
    return 0
  else
    if [ -f  ${PACKAGE_DIR}/${this_source} ] ; then
      mv ${PACKAGE_DIR}/${this_source} ${PACKAGE_ARCHIVE_DIR}/${this_source}
    fi
    dnf ${DNF_OPTIONS} repoquery --qf="%{name}" list  $(dnf ${DNF_OPTIONS}  repoquery --srpm --qf="%{sourcerpm}" --requires --resolve ${this_source} 2>/dev/null | grep -v Subscription | sed "s/.rpm$//") 2>/dev/null | grep -v Subscription | sort -u -o ${PACKAGE_DIR}/${this_source}
  fi
  return 0
}

# Given a list of binary packages, get the source name, and add it to the source_list
get_source_name(){
  if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "   GATHERING SOURCE NAMES FROM LIST OF BINARIES"
  fi
  #echo "  this_source_name= (dnf ${DNF_OPTIONS} repoquery --qf %{name} (dnf ${DNF_OPTIONS} repoquery --qf %{sourcerpm} $@ 2>/dev/null| sed 's/.rpm$//') 2>/dev/null)"
  this_source_name="$(dnf ${DNF_OPTIONS} repoquery --qf %{name} $(dnf ${DNF_OPTIONS} repoquery --qf %{sourcerpm} $@ 2>/dev/null| grep -v -e ^None$ -e "Subscription Management" | sed 's/.rpm$//') 2>/dev/null | grep -v -e ^None$ -e "Subscription Management")"
  for this_source in ${this_source_name[@]}
   do
    #echo "    SOURCE: ${this_source}"
    if [[ ! " ${SOURCE_LIST[@]} " =~ " ${this_source} " ]]; then
      if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "    ADDING SOURCE: ${this_source}"
      fi
      SOURCE_LIST+=("${this_source}")
      #if [ "${LAYERS}" == "TRUE" ] ; then
      #  echo ${this_source} >> ${OUTPUT_FILE}.layer${LAYER}
      #fi
    fi
   done
}

convert_source_to_name(){
  #if [ "${VERBOSE}" == "TRUE" ] ; then
        echo "   CONVERTING SOURCE NVRs TO NAMES"
  #fi
  file_in="${1}"
  file_out="${2}"
  if [ "${file_in}" == "" ] || [ "${file_out}" == "" ] ; then
    echo "ERROR: convert_source_to_name needs two filenames - received: ${file_in} and ${file_out}"
    exit 21
  fi
  rm -f ${file_out}
  if ! touch ${file_out} ; then
    echo "ERROR: cannot use output file: ${file_out}"
    exit 22
  fi
  if [ -s ${file_in} ] ; then
    cat ${file_in} | while read this_line
    do
       binary_name=$(echo "${this_line}" | awk '{print $1}')
       source_nvr=$(echo "${this_line}" | awk '{print $2}')
       source_name=$(grep "^${source_nvr} " ${PACKAGE_CONVERT} | awk '{print $2}')
       if [ "${source_name}" == "" ] ; then
         new_source_nvr=$(echo ${source_nvr} | sed 's/.rpm$//')
         source_name=$(dnf ${DNF_OPTIONS} repoquery --qf %{name} ${new_source_nvr} 2>/dev/null | grep -v -e ^None$ -e "Subscription Management")
         if [ "${source_name}" == "" ] ; then
           echo "     ERROR: No Source name found for: ${source_nvr}"
         else
           #if [ "${VERBOSE}" == "TRUE" ] ; then
             echo "     New Package: ${source_nvr} ${source_name}"
           #fi
           echo "${source_nvr} ${source_name}" >> ${PACKAGE_CONVERT}
         fi
       fi
       echo "${binary_name} ${source_name}" >> ${file_out}
     done
  else
    echo "ERROR: No file with content: ${file_in}"
    exit 24
  fi
}

#####
# Work
#####

# Get list of customers to check for
for customer in $(ls -1 ${CUST_DIR})
do
  echo "Customer: ${customer}"
  # Customer Setup
  ORIGINAL_LIST=()
  SOURCE_LIST=()
  BINARY_LIST=()
  LAYER=1

  customer_dir="${CUST_DIR}/${customer}"
  things_changed="False"
  depchase_repo_updated="False"
  if ! [ -d ${customer_dir}/archive ] ; then
    mkdir -p ${customer_dir}/{archive,logs,${CUST_NEW_DIR},${CUST_LAST_DIR}}
	  last_change_date="NEVER"
	  last_check_date="NEVER"
	else
	  last_change_date="$(cat ${customer_dir}/${CUST_LAST_DIR}/date.check)"
	  last_check_date="$(cat ${customer_dir}/${CUST_NEW_DIR}/date.check)"
  fi
	rm -f ${customer_dir}/${CUST_NEW_DIR}/*
	echo "${TIMESTAMP}" > ${customer_dir}/${CUST_NEW_DIR}/date.check
	cp ${customer_dir}/${CUST_LIST} ${customer_dir}/${CUST_NEW_DIR}/

  # Customer Conf Parsing
  ORIGINAL_LIST="$(cat ${customer_dir}/${CUST_LIST})"
  customer_email_list="$(grep ^Email: ${customer_dir}/${CUST_CONF} | cut -d' ' -f2-)"
  customer_action_list="$(grep ^Action: ${customer_dir}/${CUST_CONF} | cut -d' ' -f2-)"

	# Do the checks
	echo "  Checking ..."

	# Default: Always check if the customers package list has changed
	if diff --brief ${customer_dir}/${CUST_NEW_DIR}/${CUST_LIST} ${customer_dir}/${CUST_LAST_DIR}/${CUST_LIST} > /dev/null 2>&1 ; then
	  echo "    No change in package list"
	else
	  things_changed="True"
	  packages_added="$(comm -23 ${customer_dir}/${CUST_NEW_DIR}/${CUST_LIST} ${customer_dir}/${CUST_LAST_DIR}/${CUST_LIST} 2>/dev/null)"
	  packages_removed="$(comm -13 ${customer_dir}/${CUST_NEW_DIR}/${CUST_LIST} ${customer_dir}/${CUST_LAST_DIR}/${CUST_LIST} 2>/dev/null)"
	  echo "    There were changes in the package list"
	  #echo "ADDED: ${packages_added}"
	  #echo "REMOVED: ${packages_removed}"
	  echo "== PACKAGES ADDED ==" >> ${customer_dir}/${CUST_NEW_DIR}/changes
	  echo "${packages_added}" >> ${customer_dir}/${CUST_NEW_DIR}/changes
	  echo "== PACKAGES REMOVED ==" >> ${customer_dir}/${CUST_NEW_DIR}/changes
	  echo "${packages_removed}" >> ${customer_dir}/${CUST_NEW_DIR}/changes
	  echo  >> ${customer_dir}/${CUST_NEW_DIR}/changes
	fi

  ## Find the buildroot for the packages
  if [ ${#ORIGINAL_LIST[@]} -le 0 ] ; then
    echo "NO PACKAGES LISTED"
    echo
    usage
    exit 5
  else
    if [ "${VERBOSE}" == "TRUE" ] ; then
      echo "Original Binaries: ${ORIGINAL_LIST[@]}"
      get_source_name "${ORIGINAL_LIST[@]}"
      echo "Initial Source List: ${SOURCE_LIST[@]}"
    else
      get_source_name "${ORIGINAL_LIST[@]}"
    fi
  fi

  # Loop through until we no longer add sources
  number_sources=${#SOURCE_LIST[@]}
  number_new_sources=${number_sources}
  while [ ${number_new_sources} -ge 1 ]
  do
    if [ "${VERBOSE}" == "TRUE" ] || [ "${LAYERS}" == "TRUE" ] ; then
      echo "Layer: ${LAYER} Number Sources: ${number_sources} New Sources: ${number_new_sources}"
    fi
    let LAYER=${LAYER}+1
  
    get_source_name "$(dnf ${DNF_OPTIONS} repoquery --srpm --qf %{name} --requires --resolve ${SOURCE_LIST[@]} 2>/dev/null)"
  
    new_number_sources=${#SOURCE_LIST[@]}
    let number_new_sources=${new_number_sources}-${number_sources}
    number_sources=${new_number_sources}
  done
  
  # Write it all out
  printf "%s\n" "${SOURCE_LIST[@]}" | sort -o ${customer_dir}/${CUST_NEW_DIR}/source-packages-name.txt
  
  # Check if there were changes
  echo "  Checking source deps against last set"
  if diff --brief ${customer_dir}/${CUST_NEW_DIR}/source-packages-name.txt ${customer_dir}/${CUST_LAST_DIR}/source-packages-name.txt > /dev/null 2>&1 ; then
    echo "      No change in source deps"
    cp ${customer_dir}/${CUST_LAST_DIR}/binary-source-name.txt ${customer_dir}/${CUST_NEW_DIR}/binary-source-name.txt
  else
    things_changed="True"
    source_deps_added="$(comm -23 ${customer_dir}/${CUST_NEW_DIR}/source-packages-name.txt ${customer_dir}/${CUST_LAST_DIR}/source-packages-name.txt 2>/dev/null)"
    source_deps_removed="$(comm -13 ${customer_dir}/${CUST_NEW_DIR}/source-packages-name.txt ${customer_dir}/${CUST_LAST_DIR}/source-packages-name.txt 2>/dev/null)"
    echo "      There were changes in source deps"
    #echo "ADDED: ${source_deps_added}"
    #echo "REMOVED: ${source_deps_removed}"
    # Update all added and removed source deps
    for changed_source in $(echo ${source_deps_added} ${source_deps_removed})
      do
        archive_and_update ${changed_source}
      done

    # Work on added source deps
    if ! [ "${source_deps_added}" == "" ] ; then
      echo "        Added packages"
      # Update binary-source-name.txt
      dnf ${DNF_OPTIONS} repoquery --srpm --qf "%{name} %{sourcerpm}" --requires --resolve ${SOURCE_LIST[@]} 2>/dev/null | grep -v -e ^None$ -e "Subscription Management" | sort -o ${customer_dir}/${CUST_NEW_DIR}/binary-source-name.txt.tmp
      convert_source_to_name ${customer_dir}/${CUST_NEW_DIR}/binary-source-name.txt.tmp ${customer_dir}/${CUST_NEW_DIR}/binary-source-name.txt
      rm -f ${customer_dir}/${CUST_NEW_DIR}/binary-source-name.txt.tmp
      # Work with added sources
      echo "${source_deps_added}" >> ${customer_dir}/${CUST_NEW_DIR}/changes.sources.added
      echo "== SOURCE DEPENDENCIES ADDED ==" >> ${customer_dir}/${CUST_NEW_DIR}/changes
      for added_source in $(echo ${source_deps_added})
      do
        echo "${added_source}" >> ${customer_dir}/${CUST_NEW_DIR}/changes
        for added_binary in $(grep " ${added_source}$" ${customer_dir}/${CUST_NEW_DIR}/binary-source-name.txt | awk '{print $1}')
          do
            for wants_added in $(dnf ${DNF_SOURCE_ONLY_OPTIONS} repoquery --qf "%{name}" --whatrequires ${added_binary} 2>/dev/null | grep -v -e ^None$ -e "Subscription Management")
              do
                echo "- ${wants_added}" >> ${customer_dir}/${CUST_NEW_DIR}/changes
                archive_and_update ${wants_added}
              done
          done
      done
    fi
    # Work on removed source deps
    if ! [ "${source_deps_removed}" == "" ] ; then
      echo "        Removed packages"
      # Work with removed sources
      echo "${source_deps_removed}" >> ${customer_dir}/${CUST_NEW_DIR}/changes.sources.removed
      echo "== SOURCE DEPENDENCIES REMOVED ==" >> ${customer_dir}/${CUST_NEW_DIR}/changes
      for removed_source in $(echo ${source_deps_removed})
      do
        echo "${removed_source}" >> ${customer_dir}/${CUST_NEW_DIR}/changes
        archive_and_update ${removed_source}
        for wants_removed in $(grep -l ^${removed_source}$ ${PACKAGE_ARCHIVE_DIR}/* ${PACKAGE_DIR}/* 2>/dev/null | awk -F "/" '{print $NF}' | sort -u)
        do
          echo "- ${wants_removed}" >> ${customer_dir}/${CUST_NEW_DIR}/changes
          archive_and_update ${wants_removed}
        done
      done
    fi
  fi

  # If there were changes, do that thing you do
	if [ "${things_changed}" == "True" ] ; then
	  echo "  There were changes."
		echo "    Archiving last results"
		mkdir -p ${customer_dir}/archive/${last_change_date}
		cp ${customer_dir}/${CUST_LAST_DIR}/* ${customer_dir}/archive/${last_change_date}/ 2>/dev/null
		echo "    Setting new files to be the last ones"
		rm -f ${customer_dir}/${CUST_LAST_DIR}/*
		cp ${customer_dir}/${CUST_NEW_DIR}/* ${customer_dir}/${CUST_LAST_DIR}/
		for action in ${customer_action_list}
		do
      case ${action} in
        email | EMAIL | Email )
          echo "    Mailling out results"
          #mail -s "Dep Tracker: ${customer} results found" ${customer_email_list} < ${customer_dir}/${CUST_NEW_DIR}/changes
        ;;
        package | packages | Package )
          echo "    Mailling out results"
          #mail -s "Dep Tracker: ${customer} results found" ${customer_email_list} < ${customer_dir}/${CUST_NEW_DIR}/changes
        ;;
        *)
          echo "    ${action} is not implemented"
        ;;
      esac
		done
	fi
done
